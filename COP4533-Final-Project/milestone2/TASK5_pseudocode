
function TASK5 (stocks , kval): // stocks is a 2d array, kval is max allowed transactions
    profit = -1
    s =  length(stocks)
    d =  length(stocks[0])
    create 3D array opt[s][d][kval], initialized to 0
    create 1D array cmax[kval], initialized to -INF
    create 2D array buy[s][kval], initialized to 0

    
        for index n from 1 to d-1:

        for index m from 0 to s-1:
    
            for index k from 0 to kval-1: //Index k starts at 0 but represents the 1st transaction

                //Updates the current maximum profit for transactions k

                cmax[k] = max(cmax[k], stocks[m][n] - stocks[m][buy[m][k]]) 
                
                //Recurrance relations for different cases
                if(k==0 and m==0):
                     opt[m][n][k]  = cmax[k]

                else if(k==0):
                     opt[m][n][k]  = max( opt[m-1][n][k], cmax[k])

                else if(m==0):   
                    opt[m][n][k]  = max( opt[m][n-1][k], 
                                    opt[m][n-1][k-1] + cmax[k])

            
                else:
                    opt[m][n][k]  = max( opt[m-1][n][k],
                                    opt[m][n-1][k], 
                                    opt[m][n-1][k-1] + cmax[k])
                

                // Update buy day if current price is lower than previous buy day price
                if k==0 and stocks[m][n] <= stocks[m][buy[m][k]]: 
                    buy[m][k] = n

                else if( stocks[m][n] <= stocks[m][buy[m][k]]) :
                    buy[m][k] = n

                    
                // Update buy day if current price is lower than previous buy day price and a new transaction has been made
                else if(opt[m][n][k] ==  opt[m][n-1][k-1] + cmax[k] ):
                    buy[m][k] = n 
                    cmax[k] = 0


    // Find maximum profit and corresponding transaction count k
    k=-1
    profit = 0
    for index i from 0 to kval-1:
        if (opt[s-1][d-1][i] > profit):
            profit = opt[s-1][d-1][i]
            k = i
    if k==-1:
        return (0, 0, 0, 0)


    sell = length(d)-1
    m = length(s) -1
    buyd = length(d) - 2 
  // Find last sell day (where the optimal values are reused)
    transactions = []
    while sell>0:

        // Same profit without using current stock, move up
        if m>0 and opt[m][sell][k] == opt[m-1][sell][k]:
            m-=1

        // Same profit as on the previous day, move left

        else if opt[m][sell][k] == opt[m][sell-1][k]:
            sell-=1
        
        else:
            diff = opt[m][sell][k] - opt[m][sell-1][k-1]
            gap = INF
            cstock = -1
            cbuy = -1
            for index i from m down to 0:
                for index j from sell down to 0:
                    if diff == stocks[i][sell] - stocks[i][j] and sell-j < gap:
                        gap= sell-j
                        cstock = i
                        cbuy = j
                        
            if cstock==-1 :
                break
            transactions.append((cstock, cbuy, sell))
            sell = cbuy
            k-=1

        
    return transactions
  